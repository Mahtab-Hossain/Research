# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tW-2_csnBmJHnUlv7StbNjetbpwUOXfW
"""

import io
import sklearn
import numpy as np
import pandas as pd
import seaborn as sns
import plotly.express as px
import plotly.offline as plt
import plotly.graph_objs as go
from google.colab import files
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split

uploaded = files.upload()
df = pd.read_csv(io.BytesIO(uploaded['ml.csv']))
df.head(5)

df.info()

sns.countplot(df["Job Location"])

sns.countplot(df["Avg Salary(K)"])

sns.countplot(df["Size"])

df_1=df['Job Title']
df_2=df['Location']
df_3=df['Size']
df_4=df['Sector']
df_5=df['Avg Salary(K)']
df_6=df['Job Location']

# Import LabelEncoder
from sklearn import preprocessing
le = preprocessing.LabelEncoder()
# Converts string labels into integer.
df_t=le.fit_transform(df_1)
df_t2=le.fit_transform(df_2)
df_t3=le.fit_transform(df_3)
df_t4=le.fit_transform(df_4)
df_t5=le.fit_transform(df_5)
df_t6=le.fit_transform(df_6)
#df_encoder= df_encoder.reshape(-1, 1)
print("Job title Numerical values")
print(df_t)
print("Locatiton Numerical values")
print(df_t2)
print("Size Numerical values")
print(df_t3)
print("Sector")
print(df_t4)
print("This is for avg salary (k)")
print(df_t5)
print("Job location in numerical value")
print(df_t6)

!pip install category_encoders

import category_encoders as ce

# split X and y into training and testing sets
X = df.drop(['job_title_sim'], axis=1)

y = df['job_title_sim']

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 0)
# check the shape of X_train and X_test

X_train.shape, X_test.shape

encoder = ce.OneHotEncoder(cols=['Job Title','Location','Size','Sector','Avg Salary(K)'])
X_train=encoder.fit_transform(X_train)
X_test=encoder.transform(X_test)

ft1 = list(zip(df_t,df_t2))
from sklearn.neighbors import KNeighborsClassifier
model = KNeighborsClassifier(n_neighbors=3)
#training sets
model.fit(ft1,df_t3)
#Predict Output
predicted= model.predict([[0,2]])
print(predicted)

X_train, X_test, y_train, y_test = train_test_split(ft1,df_t4, test_size=0.3)
knn = KNeighborsClassifier(n_neighbors=5)
#training sets
knn.fit(X_train, y_train)
#predicting the response for test dataset
y_pred = knn.predict(X_test)

from sklearn import metrics
from sklearn.metrics import classification_report, confusion_matrix
# Model Accuracy
print("accuracy:",metrics.accuracy_score(y_test, y_pred))
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

neighbors = np.arange(1, 9)
train_accuracy = np.empty(len(neighbors))
test_accuracy = np.empty(len(neighbors))
#loop for diff val of k
for i, k in enumerate(neighbors):
    knn = KNeighborsClassifier(n_neighbors=k)
    #fiting training data
    knn.fit(X_train, y_train)
    #compute accuracy on the training set
    train_accuracy[i] = knn.score(X_train, y_train)
    #Compute accuracy on the testing set
    test_accuracy[i] = knn.score(X_test, y_test)
plt.plot(neighbors, test_accuracy, label = 'Test Accuracy')
plt.plot(neighbors, train_accuracy, label = 'Train Accuracy')
plt.legend()
plt.xlabel('Number of Neighbors')
plt.ylabel('Accuracy')
plt.show()

error = []
#error ploting diff k val
for i in range(1, 40):
    knn = KNeighborsClassifier(n_neighbors=i)
    knn.fit(X_train, y_train)
    pred_i = knn.predict(X_test)
    error.append(np.mean(pred_i != y_test))
plt.figure(figsize=(12, 6))
plt.plot(range(1, 40), error, color='green', linestyle= 'solid', marker='v',markerfacecolor='red', markersize=10)
plt.title('error rate for k values')
plt.xlabel('number of n_neighbours')
plt.ylabel('Avrage error')
plt.savefig('errork.png')

from sklearn.naive_bayes import GaussianNB
nbModel = GaussianNB()
nbModel.fit(ft1,df_t)
GaussianNB(priors=None, var_smoothing=1e-09)

y_pred = nbModel.predict(X_test)
print(y_pred)

from sklearn.metrics import accuracy_score

print('Model accuracy score: {0:0.4f}'. format(accuracy_score(df_t,df_t5)))

